---
title: JVM内存模型
date: 2021/02/03 12:07:27
updated: 2021/02/03 12:07:27
categories:
- [技术, JVM]
tags:
- JVM
- Java
---



## JVM 内存结构

- 每个线程都只能访问自己的线程栈。
- 每个线程都不能访问（看不见）其他线程的局部变量。
- 所有原生类型的局部变量都存储在线程栈中，因此对其他线程是不可见的。
- 线程可以将一个原生变量值的副本传给另一个线程，但不能共享原生局部变量本身。
- 堆内存中包含了 Java 代码中创建的所有对象，不管是哪个线程创建的。 其中也涵盖了包装类型（例如 Byte，Integer，Long 等）。
- 不管是创建一个对象并将其赋值给局部变量， 还是赋值给另一个对象的成员变量， 创建的对象都会被保存到堆内存中。



![JVM内存模型](./assets/image-20240421134405156.png)

![JVM内存结构](./assets/image-20240421134507423.png)

- 如果是原生数据类型的局部变量，那么它的内容就全部保留在线程栈上。
- 如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中。
- 对象的成员变量与对象本身一起存储在堆上, 不管成员变量的类型是原生数值，还是对象引用。
- 类的静态变量则和类定义一样都保存在堆中。









![JVM内存结构](./assets/image-20240421134600866.png)

- 方法中使用的原生数据类型和对象引用地址在栈上存储；对象、对象成员与类定义、静态变量在堆上。
- 堆内存又称为“共享堆”，堆中的所有对象，可以被所有线程访问, 只要他们能拿到对象的引用地址。
- 如果一个线程可以访问某个对象时，也就可以访问该对象的成员变量。
- 如果两个线程同时调用某个对象的同一方法，则它们都可以访问到这个对象的成员变量，但每个线程的局部变量副本是独立的。



### JVM 内存整体结构

![JVM 内存整体结构](./assets/image-20240421134731160.png)



- 每启动一个线程，JVM 就会在栈空间栈分配对应的 线程栈, 比如 1MB 的空间（\-Xss1m）。
- 线程栈也叫做 Java 方法栈。 如果使用了JNI 方法，则会分配一个单独的本地方法栈(Native Stack)。
- 线程执行过程中，一般会有多个方法组成调用栈（Stack Trace）, 比如 A 调用 B，B 调用 C…每执行到一个方法，就会创建对应的 栈帧（Frame）。



### JVM 栈内存结构

![JVM 栈内存结构](./assets/image-20240421134849652.png)

栈帧是一个逻辑上的概念，具体的大小在一个方法编写完成后基本上就能确定。

比如返回值需要有一个空间存放，每个局部变量都需要对应的地址空间，此外还有给指令使用的操作数栈，以及 class 指针（标识这个栈帧对应的是哪个类的方法, 指向非堆里面的 Class 对象）。





### JVM 堆内存结构

![JVM 堆内存结构](./assets/image-20240421135024108.png)

- 堆内存是所有线程共用的内存空间，JVM 将Heap 内存分为年轻代（Young generation）和 老年代（Old generation, 也叫 Tenured）两部分。
- 年轻代还划分为 3 个内存池，新生代（Eden space）和存活区（Survivor space）, 在大部分GC 算法中有 2 个存活区（S0, S1），在我们可以观察到的任何时刻，S0 和 S1 总有一个是空的, 但一般较小，也不浪费多少空间。
- Non-Heap 本质上还是 Heap，只是一般不归 GC管理，里面划分为 3 个内存池。
- Metaspace, 以前叫持久代（永久代, Permanent generation）, Java8 换了个名字叫 Metaspace。
- CCS, Compressed Class Space, 存放 class 信息的，和 Metaspace 有交叉。
- Code Cache存放 JIT 编译器编译后的本地机器代码。





## JMM

JMM 规范对应的是“[JSR-133. Java Memory Model and Thread Specification]”，《Java 语言规范》的 [$17.4. Memory Model章节]

JMM 规范明确定义了不同的线程之间，通过哪些方式，在什么时候可以看见其他线程保存到共享变量中的值；以及在必要时，如何对共享变量的访问进行同步。这样的好处是屏蔽各种硬件平台和操作系统之间的内存访问差异，实现了 Java 并发程序真正的跨平台。



- 所有的对象（包括内部的实例成员变量），static 变量，以及数组，都必须存放到堆内存中。
- 局部变量，方法的形参/入参，异常处理语句的入参不允许在线程之间共享，所以不受内存模型的影响。
- 多个线程同时对一个变量访问时【读取/写入】，这时候只要有某个线程执行的是写操作，那么这种现象就称之为“冲突”。
- 可以被其他线程影响或感知的操作，称为线程间的交互行为， 可分为： 读取、写入、同步操作、外部操作等等。 其中同步操作包括：对 volatile 变量的读写，对管程（monitor）的锁定与解锁，线程的起始操作与结尾操作，线程启动和结束等等。 外部操作则是指对线程执行环境之外的操作，比如停止其他线程等等。
- JMM 规范的是线程间的交互操作，而不管线程内部对局部变量进行的操作。